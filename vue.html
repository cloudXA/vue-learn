<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

</head>
<body>
    <!-- 父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态 -->
    <div id="app">
        <!-- // 在html中是kebab-case 的 -->
        <blog-post v-bind:level="1"></blog-post>
        
      
    </div>
    <script src="./node_modules/./vue/dist/vue.js"></script>

    <script>
        var EmptyList = {}
        var TableList = {}
        var OrderedList = {}
        var UnorderedList = {}

        Vue.component('smart-list', {
            functional: true,
            props: {
                items: {
                    type: Array,
                    required: true
                },
                isOrdered: Boolean
            },
            render(h, context) {
                function appropriateListComponent() {
                    var items = context.props.items

                    if(items.length === 0) return EmptyList
                    if(typeof items[0] === 'object') return TableList
                    if(context.props.isOrdered) return OrderedList

                    return UnorderedList
                }

                // return createElement(
                //     appropriateListComponent(),
                //     context.data,
                //     comtext.children
                // )

                // 完全透传任何attribute 事件监听器 子节点
                return createElement('button', context.data, context.children)

                // 通过向createElement传入context.data 作为第二个参数，我们就把smart-list 上面所有的attribute
                // 和事件监听器都传递下去了。事实上这是非常透明的，以至于那些事件甚至并不要求.native修饰符
            },
        })
        
        new Vue({
            el: '#app',
            data() {
                return {
                    // items: {text: '你好'}
                }
            },
        })
        
    </script>

