<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="./node_modules/./vue/dist/vue.js"></script>
    <title>Document</title>

</head>
<body>
    <div id="app">
        <!-- 父级  -->
        <!-- 我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称： -->
        <!-- 现在 <template> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 <template> 中的内容都会被视为默认插槽的内容。 -->
            <!-- 注意 v-slot 只能添加在 <template> 上  -->
        <!-- 为了让user在父级的插槽可以使用，我们可以将user作为slot元素的一个attribute绑定上去 -->
        <!-- num 2 绑定在 <slot> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字： -->

        <!-- 让插槽的内容能够访问子组件中才有的数据 -->

        <!-- 注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确： -->
        <!-- 不带参数的 v-slot 被假定对应默认插槽 -->
        <navgation-link url="url" v-bind:title="title">

            <!-- num 1  -->
            <!-- 这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽： -->
              <!-- <template v-slot:default="slotData">
                {{ slotData.user.name }}
              </template> -->
              <!-- 作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个单数的函数里 -->
              <!-- 这意味着v-slot的值实际上是任何能够作为函数定义中的参数的JavaScript表达式
            可以使用es6解构来传入具体的prop,尤其当插槽提供了多个prop的时候 -->

            <!-- 动态插槽名 -->
            <!-- 如何将dynamicSlotName与实例属性值相对应，需要进一步学习TODO:  -->

            <!-- 具名插槽的缩写，与其他指令一样，该缩写只在其有参数的时候才可以使用 -->

            <!-- 这样会触发一个警告 -->
            <!-- <current-user #="{ user }">
                {{ user.firstName }}
            </current-user> -->


            <!-- 如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：
            <current-user #default="{ user }">
                {{ user.firstName }}
              </current-user> -->

              <template #other="{ other }">
                {{ other.name }}
              </template>

              <!-- 将user重命名为person -->
              <template v-slot="{ user : person }">
                {{ person.name }}
              </template>

              <!-- 定义后备内容，用于插槽prop是undefiend的情形 -->
              <template #nothing="{ nothing = { name: 'Guest' } }">
                {{ nothing.name }}
              </template>
             
            
        </navgation-link>

        <navgation-links >
            
        </navgation-links>

    </div>

    <script>
    // 全局组件
    Vue.component('navgation-link', {
        data() {
            return {
                url: '/components',
                dynamicSlotName: "other",
                colorSetting: {
                    color: 'red'
                },
                slotData: {
                    name: '李四guang',
                    age: 18
                },
                otherSlotProps: {
                    name: '石油地质'
                },
                // 此处插槽prop是undefined的情形
                // nothing: {
                //     name: undefined
                // }
            }
        },
        
    //   slot具有一个特殊的attribute： name 这个attribute可以用来定义额外的插槽，一个不带 name 的 <slot> 出口会带有隐含的名字“default”。
        // num1将 user 作为 <slot> 元素的一个 attribute 绑定上去

            // num 2 
     // 只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法：  
        template: `<div class="container">
                        <slot v-bind:user="slotData" name="default">
                            
                        </slot>

                        <slot v-bind:other="otherSlotProps" name="other">
                           
                        </slot>

                        <slot v-bind:nothing="nothing" name="nothing">
                           
                        </slot>

                    </div>
                    `

    })

    var vm = new Vue({
        el: '#app',
        data: {
            title: '你是电逆时光',


        },
        methods:{
           
        },
        components: {

            NavgationLinks : {
                template: `<div>
                         <h1>hi...</h1>
                         <slot></slot>
                        </div>
                     `
                            ,
                data(){
                    return {

                    }
                },
                methods: {

                }
            }
        }
    })
 

    </script>